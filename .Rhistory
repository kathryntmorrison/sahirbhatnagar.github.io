A <- A + delta.A
# stopping criteria
d1 <- dpois(j, lambda=theta[2])
d2 <- dpois(j, lambda=theta[3])
omegabar <- (theta[1]*d1)/(theta[1]*d1 + (1-theta[1])*d2)
gradient.current <- gradient(j=j,cj=cj, omega=theta[1], omegabar=omegabar, theta1=theta[2], theta2=theta[3])
rg.next <- rg(j=j,cj=cj, gradient=gradient.current, theta.current=theta, delta.theta=delta.theta)
keepgoing <- max(rg.next)>=epsilon
theta <- theta+delta.theta
g.tilde <- g.tilde + delta.g.tilde
i <- i+1
}
return(list(omega=theta[1],theta1=theta[2],theta2=theta[3], iter=i))
}
values <- list(seq.int(0,6,1), seq.int(0,9,1),seq.int(0,6,1))
counts <- list(c(552,703,454,180,84,23,4), c(162,267,271,185,111,61,27,8,3,1), c(3062,587,284,103,33,4,2))
mapply(function(x,y,z) my.em(j=x, cj=y, epsilon=z), values, counts,1e-6)
mapply(function(x,y,z) my.qn1(j=x, cj=y, epsilon=z), values, counts , 1e-6)
lapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]]) } )
# EM algorithm ------------------------------------------------------------
gradient <- function(j, cj, omega, omegabar, theta1, theta2){
dQ.domega <- (1/(omega*(1-omega)))*(sum(cj*(omegabar-omega)))
dQ.dtheta1 <- (1/theta1)*(sum(cj*omegabar*(j-theta1)))
dQ.dtheta2 <- (1/theta2)*(sum(cj*(1-omegabar)*(j-theta2)))
return(c(dQ.domega,dQ.dtheta1,dQ.dtheta2))
}
incomplete.log.lik <- function(theta, j, cj){
ell <- sum(cj*log(theta[1]*exp(-theta[2])*(theta[2]^j) +
(1-theta[1])*exp(-theta[3])*(theta[3]^j)))
return(ell)
}
rg <- function(j, cj, gradient, theta.current, delta.theta){
ratio <- abs(gradient)*(pmax(abs(theta.current+delta.theta), 1)/(pmax(abs(incomplete.log.lik(j=j, cj=cj,theta=theta.current+delta.theta)),1)))
return(ratio)
}
my.em <- function (j,cj, omega.init=0.5, theta1.init=1, theta2.init=2, epsilon=1e-6, i=1, keepgoing=TRUE){
while(keepgoing){
d1 <- dpois(j, lambda=theta1.init)
d2 <- dpois(j, lambda=theta2.init)
omegabar <- (omega.init*d1)/(omega.init*d1 + (1-omega.init)*d2)
omega.next <- sum(cj*omegabar)/sum(cj)
theta1.next <- sum(j*cj*omegabar)/sum(cj*omegabar)
theta2.next <- sum(j*cj*(1-omegabar))/sum(cj*(1-omegabar))
theta.new <- c(omega.next, theta1.next, theta2.next)
theta.old <- c(omega.init, theta1.init, theta2.init)
delta.theta <- theta.old-theta.new
gradient.current <- gradient(j=j,cj=cj, omega=omega.init, omegabar=omegabar, theta1=theta1.init, theta2=theta2.init)
rg.next <- rg(j=j,cj=cj, gradient=gradient.current, theta.current=theta.old, delta.theta=delta.theta)
keepgoing <- max(rg.next)>=epsilon
omega.init <- omega.next
theta1.init <- theta1.next
theta2.init <- theta2.next
i <- i+1
}
return(list(omega=omega.next,theta1=theta1.next,theta2=theta2.next, iter=i))
}
# QN1 algorithm ---------------------------------------------------------------------
M.theta <- function(j,cj, theta){
d1 <- dpois(j, lambda=theta[2])
d2 <- dpois(j, lambda=theta[3])
omegabar <- (theta[1]*d1)/(theta[1]*d1 + (1-theta[1])*d2)
omega.next <- sum(cj*omegabar)/sum(cj)
theta1.next <- sum(j*cj*omegabar)/sum(cj*omegabar)
theta2.next <- sum(j*cj*(1-omegabar))/sum(cj*(1-omegabar))
return(c(omega.next, theta1.next, theta2.next))
}
my.qn1 <- function(j,cj, omega.init=0.5, theta1.init=1, theta2.init=2, epsilon=1e-6, i=1, keepgoing=TRUE){
#j=values[[1]] ; cj=counts[[1]] ; omega.init=0.5; theta1.init=1;theta2.init=2;epsilon=1e-6;i=1;
theta <- c(omega.init, theta1.init, theta2.init)
g.tilde <- M.theta(j=j,cj=cj, theta=theta) - theta
A <- -diag(3)
while(keepgoing){
delta.theta <- -A%*%as.matrix(g.tilde)
# check if estimates lie in parameter space
in.param.space <- (theta+delta.theta)[1] > 0 & (theta+delta.theta)[1] < 1 & (theta+delta.theta)[2] > 0 & (theta+delta.theta)[3] > 0
while(!in.param.space){
delta.theta <- delta.theta/2
#theta <- theta + delta.theta
theta.temp <- theta + delta.theta
in.param.space <- theta.temp[1] > 0 & theta.temp[1] < 1 & theta.temp[2] > 0 & theta.temp[3] > 0
}
delta.g.tilde <- M.theta(j=j,cj=cj, theta=theta+delta.theta)-(theta+delta.theta)-g.tilde
delta.A <- ((delta.theta-A%*% delta.g.tilde) %*% t(delta.theta)%*%A)*(1/(as.numeric(t(delta.theta)%*%A%*%delta.g.tilde)))
A <- A + delta.A
# stopping criteria
d1 <- dpois(j, lambda=theta[2])
d2 <- dpois(j, lambda=theta[3])
omegabar <- (theta[1]*d1)/(theta[1]*d1 + (1-theta[1])*d2)
gradient.current <- gradient(j=j,cj=cj, omega=theta[1], omegabar=omegabar, theta1=theta[2], theta2=theta[3])
rg.next <- rg(j=j,cj=cj, gradient=gradient.current, theta.current=theta, delta.theta=delta.theta)
keepgoing <- max(rg.next)>=epsilon
theta <- theta+delta.theta
g.tilde <- g.tilde + delta.g.tilde
i <- i+1
}
return(list(omega=theta[1],theta1=theta[2],theta2=theta[3], iter=i))
}
values <- list(seq.int(0,6,1), seq.int(0,9,1),seq.int(0,6,1))
counts <- list(c(552,703,454,180,84,23,4), c(162,267,271,185,111,61,27,8,3,1), c(3062,587,284,103,33,4,2))
mapply(function(x,y,z) my.em(j=x, cj=y, epsilon=z), values, counts,1e-6)
mapply(function(x,y,z) my.qn1(j=x, cj=y, epsilon=z), values, counts , 1e-6)
lapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]]) } )
i=1
optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]])
lapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], lower=0) } )
lapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1)) } )
i=1
optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1))
i=2
optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1))
i=3
optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1))
mapply(function(x,y,z) my.em(j=x, cj=y, epsilon=z), values, counts,1e-6)
mapply(function(x,y,z) my.qn1(j=x, cj=y, epsilon=z), values, counts , 1e-6)
lapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1)) } )
lapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1))$par } )
sapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1))$par } )
library(plyr)
ldply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1))$par } )
sapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1))$par } )
lapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1))$par } )
# EM algorithm ------------------------------------------------------------
gradient <- function(j, cj, omega, omegabar, theta1, theta2){
dQ.domega <- (1/(omega*(1-omega)))*(sum(cj*(omegabar-omega)))
dQ.dtheta1 <- (1/theta1)*(sum(cj*omegabar*(j-theta1)))
dQ.dtheta2 <- (1/theta2)*(sum(cj*(1-omegabar)*(j-theta2)))
return(c(dQ.domega,dQ.dtheta1,dQ.dtheta2))
}
incomplete.log.lik <- function(theta, j, cj){
ell <- sum(cj*log(theta[1]*exp(-theta[2])*(theta[2]^j) +
(1-theta[1])*exp(-theta[3])*(theta[3]^j)))
return(ell)
}
rg <- function(j, cj, gradient, theta.current, delta.theta){
ratio <- abs(gradient)*(pmax(abs(theta.current+delta.theta), 1)/(pmax(abs(incomplete.log.lik(j=j, cj=cj,theta=theta.current+delta.theta)),1)))
return(ratio)
}
my.em <- function (j,cj, omega.init=0.5, theta1.init=1, theta2.init=2, epsilon=1e-6, i=1, keepgoing=TRUE){
while(keepgoing){
d1 <- dpois(j, lambda=theta1.init)
d2 <- dpois(j, lambda=theta2.init)
omegabar <- (omega.init*d1)/(omega.init*d1 + (1-omega.init)*d2)
omega.next <- sum(cj*omegabar)/sum(cj)
theta1.next <- sum(j*cj*omegabar)/sum(cj*omegabar)
theta2.next <- sum(j*cj*(1-omegabar))/sum(cj*(1-omegabar))
theta.new <- c(omega.next, theta1.next, theta2.next)
theta.old <- c(omega.init, theta1.init, theta2.init)
delta.theta <- theta.old-theta.new
gradient.current <- gradient(j=j,cj=cj, omega=omega.init, omegabar=omegabar, theta1=theta1.init, theta2=theta2.init)
rg.next <- rg(j=j,cj=cj, gradient=gradient.current, theta.current=theta.old, delta.theta=delta.theta)
keepgoing <- max(rg.next)>=epsilon
omega.init <- omega.next
theta1.init <- theta1.next
theta2.init <- theta2.next
i <- i+1
}
return(list(omega=omega.next,theta1=theta1.next,theta2=theta2.next, iter=i))
}
# QN1 algorithm ---------------------------------------------------------------------
M.theta <- function(j,cj, theta){
d1 <- dpois(j, lambda=theta[2])
d2 <- dpois(j, lambda=theta[3])
omegabar <- (theta[1]*d1)/(theta[1]*d1 + (1-theta[1])*d2)
omega.next <- sum(cj*omegabar)/sum(cj)
theta1.next <- sum(j*cj*omegabar)/sum(cj*omegabar)
theta2.next <- sum(j*cj*(1-omegabar))/sum(cj*(1-omegabar))
return(c(omega.next, theta1.next, theta2.next))
}
my.qn1 <- function(j,cj, omega.init=0.5, theta1.init=1, theta2.init=2, epsilon=1e-6, i=1, keepgoing=TRUE){
#j=values[[1]] ; cj=counts[[1]] ; omega.init=0.5; theta1.init=1;theta2.init=2;epsilon=1e-6;i=1;
theta <- c(omega.init, theta1.init, theta2.init)
g.tilde <- M.theta(j=j,cj=cj, theta=theta) - theta
A <- -diag(3)
while(keepgoing){
delta.theta <- -A%*%as.matrix(g.tilde)
# check if estimates lie in parameter space
in.param.space <- (theta+delta.theta)[1] > 0 & (theta+delta.theta)[1] < 1 & (theta+delta.theta)[2] > 0 & (theta+delta.theta)[3] > 0
while(!in.param.space){
delta.theta <- delta.theta/2
#theta <- theta + delta.theta
theta.temp <- theta + delta.theta
in.param.space <- theta.temp[1] > 0 & theta.temp[1] < 1 & theta.temp[2] > 0 & theta.temp[3] > 0
}
delta.g.tilde <- M.theta(j=j,cj=cj, theta=theta+delta.theta)-(theta+delta.theta)-g.tilde
delta.A <- ((delta.theta-A%*% delta.g.tilde) %*% t(delta.theta)%*%A)*(1/(as.numeric(t(delta.theta)%*%A%*%delta.g.tilde)))
A <- A + delta.A
# stopping criteria
d1 <- dpois(j, lambda=theta[2])
d2 <- dpois(j, lambda=theta[3])
omegabar <- (theta[1]*d1)/(theta[1]*d1 + (1-theta[1])*d2)
gradient.current <- gradient(j=j,cj=cj, omega=theta[1], omegabar=omegabar, theta1=theta[2], theta2=theta[3])
rg.next <- rg(j=j,cj=cj, gradient=gradient.current, theta.current=theta, delta.theta=delta.theta)
keepgoing <- max(rg.next)>=epsilon
theta <- theta+delta.theta
g.tilde <- g.tilde + delta.g.tilde
i <- i+1
}
return(list(omega=theta[1],theta1=theta[2],theta2=theta[3], iter=i))
}
values <- list(seq.int(0,6,1), seq.int(0,9,1),seq.int(0,6,1))
counts <- list(c(552,703,454,180,84,23,4), c(162,267,271,185,111,61,27,8,3,1), c(3062,587,284,103,33,4,2))
mapply(function(x,y,z) my.em(j=x, cj=y, epsilon=z), values, counts,1e-6)
mapply(function(x,y,z) my.qn1(j=x, cj=y, epsilon=z), values, counts , 1e-6)
# Optim -------------------------------------------------------------------
lapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1))$par } )
lapply(1:3,function(i) {optim(c(0.5,1,2), fn=incomplete.log.lik,j=values[[i]], cj=counts[[i]], control=list(fnscale=-1,trace=10,maxit=10000))$par } )
p=25
ff <- array(NA, c(1000,2^p))
p=25
ff <- array(NA, c(1000,2^p))
2^25
ff <- array(0, c(1000,2^p))
ff <- array(1, c(1000,2^p))
ff <- matrix(rep(NA,2^p))
ff <- matrix(rep(NA,2^p))
library("bootstrap", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.1")
data("cholost")
summary(cholost)
plot(y ~ z, data=cholost, xlab="Compliance",
ylab="Improvement")
abline(lm(y ~ z, data=cholost), col="red")
hist(cholost$y)
hist(cholost$z)
cholost$z
y <- cholost$z
n <- length(y)
ty <- (y*(n-1)+0.5)/n
hist(ty)
hist(cholost$z)
hist(ty)
y <- cholost$z
n <- length(y)
n=100
ty <- (y*(n-1)+0.5)/n
hist(ty)
n=50
ty <- (y*(n-1)+0.5)/n
hist(ty)
ty
y <- cholost$z
n <- length(y)
ty <- log(y/(1-y))
n <- length(y)
ty <- log((y/n)/(1-(y/n)))
hist(ty)
order(y)
y[order(y)]
p.adjust.methods()
p.adjust.methods
source("http://bioconductor.org/biocLite.R")
biocLite("qvalue")
1/101
1/100
a.al<-1
b.al<-1
a.be<-1
b.be<-1
Al<-rgamma(10000,a.al,b.al)
Be<-rgamma(10000,a.be,b.be)
hist(Al/(Al+Be))
mvec<-c(18,9,10,6,8,11,13,11)
yvec<-c(13,2,2,0,3,3,6,1)
n<-length(yvec)
##########################################
jt.like<-function(yv,mv,thv,alv,bev){
return(dbinom(yv,mv,thv,log=T)+dbeta(thv,alv,bev,log=T))
}
prior.func<-function(alv,bev,aa,ab,ba,bb){
return(dgamma(alv,aa,ab,log=T)+dgamma(bev,ba,bb,log=T))
}
##########################################
nburn<-20
nthin<-1
nsamp<-2000
nits<-nburn+nthin*nsamp
old.al<-old.be<-1
old.th<-(yvec+old.al)/(mvec+old.al+old.be)
old.likei<-jt.like(yvec,mvec,old.th,old.al,old.be)
old.like<-sum(old.likei)
old.prior<-prior.func(old.al,old.be,a.al,b.al,a.be,b.be)
ico<-0
theta.samp.1<-matrix(0,nrow=nsamp,ncol=n)
albe.samp.1<-matrix(0,nrow=nsamp,ncol=2)
for(iter in 1:nits){
#Update the thetas in parallel
new.th<-old.th+rnorm(n)*0.1
new.th[new.th <= 0 | new.th >= 1]<-old.th[new.th <= 0 | new.th >= 1]
new.likei<-jt.like(yvec,mvec,new.th,old.al,old.be)
acc<-log(runif(n)) < new.likei-old.likei
old.th[acc]<-new.th[acc]
old.likei[acc]<-new.likei[acc]
#Update alpha and beta using a Gibbs sampler
new.al<-abs(rnorm(1,old.al,0.2))
new.likei<-jt.like(yvec,mvec,old.th,new.al,old.be)
if(log(runif(1)) < (sum(new.likei)+dgamma(new.al,a.al,b.al,log=T))-(sum(old.likei)+dgamma(old.al,a.al,b.al,log=T))){
old.al<-new.al
old.likei<-new.likei
}
new.be<-abs(rnorm(1,old.be,0.2))
new.likei<-jt.like(yvec,mvec,old.th,old.al,new.be)
if(log(runif(1)) < (sum(new.likei)+dgamma(new.be,a.be,b.be,log=T))-(sum(old.likei)+dgamma(old.be,a.be,b.be,log=T))){
old.be<-new.be
old.likei<-new.likei
}
if(iter > nburn & iter %% nthin == 0){
ico<-ico+1
theta.samp.1[ico,]<-old.th
albe.samp.1[ico,]<-c(old.al,old.be)
}
}
a.al<-1
b.al<-1
a.be<-1
b.be<-1
Al<-rgamma(10000,a.al,b.al)
Be<-rgamma(10000,a.be,b.be)
hist(Al/(Al+Be))
mvec<-c(18,9,10,6,8,11,13,11)
yvec<-c(13,2,2,0,3,3,6,1)
n<-length(yvec)
##########################################
jt.like<-function(yv,mv,thv,alv,bev){
return(dbinom(yv,mv,thv,log=T)+dbeta(thv,alv,bev,log=T))
}
prior.func<-function(alv,bev,aa,ab,ba,bb){
return(dgamma(alv,aa,ab,log=T)+dgamma(bev,ba,bb,log=T))
}
##########################################
nburn<-20
nthin<-1
nsamp<-2000
nits<-nburn+nthin*nsamp
old.al<-old.be<-1
old.th<-(yvec+old.al)/(mvec+old.al+old.be)
old.likei<-jt.like(yvec,mvec,old.th,old.al,old.be)
old.like<-sum(old.likei)
old.prior<-prior.func(old.al,old.be,a.al,b.al,a.be,b.be)
ico<-0
theta.samp.1<-matrix(0,nrow=nsamp,ncol=n)
albe.samp.1<-matrix(0,nrow=nsamp,ncol=2)
for(iter in 1:nits){
#Update the thetas in parallel
new.th<-old.th+rnorm(n)*0.1
new.th[new.th <= 0 | new.th >= 1]<-old.th[new.th <= 0 | new.th >= 1]
new.likei<-jt.like(yvec,mvec,new.th,old.al,old.be)
acc<-log(runif(n)) < new.likei-old.likei
old.th[acc]<-new.th[acc]
old.likei[acc]<-new.likei[acc]
#Update alpha and beta using a Gibbs sampler
new.al<-abs(rnorm(1,old.al,0.2))
new.likei<-jt.like(yvec,mvec,old.th,new.al,old.be)
if(log(runif(1)) < (sum(new.likei)+dgamma(new.al,a.al,b.al,log=T))-(sum(old.likei)+dgamma(old.al,a.al,b.al,log=T))){
old.al<-new.al
old.likei<-new.likei
}
new.be<-abs(rnorm(1,old.be,0.2))
new.likei<-jt.like(yvec,mvec,old.th,old.al,new.be)
if(log(runif(1)) < (sum(new.likei)+dgamma(new.be,a.be,b.be,log=T))-(sum(old.likei)+dgamma(old.be,a.be,b.be,log=T))){
old.be<-new.be
old.likei<-new.likei
}
if(iter > nburn & iter %% nthin == 0){
ico<-ico+1
theta.samp.1[ico,]<-old.th
albe.samp.1[ico,]<-c(old.al,old.be)
}
}
kkk
ls
install.packages("arm")
vars <- combn(names(mtcars)[-1], 8)
vars
vars
x <- function(s){
afd
dfd
fdf
)
iris %>%
{
n <- sample(1:10, size = 1)
H <- head(., n)
T <- tail(., n)
rbind(H, T)
} %>%
summary
library(magrittr)
iris %>%
{
n <- sample(1:10, size = 1)
H <- head(., n)
T <- tail(., n)
rbind(H, T)
} %>%
summary
iris %>%
{
n <- sample(1:10, size = 1)
H <- head(., n)
T <- tail(., n)
rbind(H, T)
} %>%
summary
iris %>%
{
n <- sample(1:10, size = 1)
H <- head(., n)
T <- tail(., n)
rbind(H, T)
} %>%
print()
install_github("thell/knitLiteral")
for(i in 1:5){cos(sin(i)*i^2)+3 %>% .-5 %>% print
)
for(i in 1:5) {cos(sin(i)*i^2)+3 %>% .-5 %>% print}
for(i in 1:5) {cos(sin(i)*i^2)+3 %>% {-5} %>% print}
diff(2,2)
diff(2,1)
diff(2,9)
for(i in 1:5) {cos(sin(i)*i^2)+3 %>% {sum(.,-5)} %>% print}
for(i in 1:5) {cos(sin(i)*i^2)+3 %>% sum(.,-5) %>% print}
for(i in 1:5) {cos(sin(i)*i^2)+3 %>% sum(.,-3) %>% print}
for(i in 1:5) {i+3 %>% sum(.,-3) %>% print}
for(i in 1:5) {i+3 %>% sum(.,-10) %>% print}
for(i in 1:5) {i+3 %>% .-10 %>% print}
for(i in 1:5) {i+3 %>% print}
for(i in 1:5){i+3 %>% print}
for(i in 1:5){(i+3) %>% print}
cat("\Sexpr{...}")
cat("\\Sexpr{...}")
cat(paste("\\Sexpr{...}"))
cat(paste("\\Sexpr{ncol(iris)}"))
library(xtable)
iris[1:5,1:5] %>% xtable(caption='Sample of Iris data') %>% print(include.rownames=FALSE)
citation("ALL")
sessionInfo()
citation("ALL")
source("https://github.com/adminGreenwoodLab/knitr-tutorial/blob/master/003-model-output/003-texreg-geepack.R")
library(devtools)
source("https://github.com/adminGreenwoodLab/knitr-tutorial/blob/master/003-model-output/003-texreg-geepack.R")
devtools::source_gist("https://gist.github.com/sahirbhatnagar/178619f32963b30ba8b2")
setwd("~/git_repositories/sahirbhatnagar.github.io")
install.packages("servr")
servr::jekyll(input = "_source/2015-06-10-heatmaps.Rmd",script = "_knitr/build.R")
servr::jekyll(script = "_knitr/build.R")
RColorBrewer::display.brewer.all()
RColorBrewer::display.brewer.pal()
RColorBrewer::display.brewer.all()
servr::jekyll(script = "_knitr/build.R")
servr::jekyll(script = "_knitr/build.R", serve = FALSE)
install.packages("pheatmap")
servr::jekyll(script = "_knitr/build.R", serve = FALSE)
servr::jekyll(script = "_knitr/build.R", serve = FALSE)
servr::jekyll(script = "_knitr/build.R", serve = FALSE)
servr::jekyll(script = "_knitr/build.R", serve = FALSE)
servr::jekyll(script = "_knitr/build.R", serve = FALSE)
n = 100       # total number of subjects
n0 = 50       # number of subjects with X=0
n1 = n - n0   # number of subjects with X=1
p = 100       # number of genes
times = 1:p   # used for creating covariance matrix
rho.0 = 0.01  # rho between Z_i and Z_j when X=0
rho.1 = 0.95  # rho between Z_i and Z_j when X=1
sigma = 1
annotation_col = data.frame(
Exposure = factor(c(rep("X=0",n0),rep("X=1", n1)))
)
rownames(annotation_col) = paste0("Subject", 1:n)
annotation_col
annotation_col[46:54,]
annotation_col[46:54]
annotation_col[c("Sucject1"),]
annotation_col[c("Subject1"),]
annotation_col[paste0("Subject",47:53),]
annotation_col[paste0("Subject",47:53),]
annotation_col[paste0("Subject",47:53),] %>% print
library(magrittr)
annotation_col[paste0("Subject",47:53),] %>% print
annotation_col %>% head
annotation_col %>% sample(10) %>% head
annotation_col %>% head
str(annotation_col)
annotation_col[1:5,]
annotation_col[1:5,] %>% print
annotation_col %>% print
annotation_col %>% head
annotation_col = data.frame(
Exposure = factor(c(rep("X=0",n0),rep("X=1", n1)))
)
annotation_col
Exposure = c(rep("X=0",n0),rep("X=1", n1)) %>% factor
Exposure
Exposure = c(rep("X=0",n0),rep("X=1", n1)) %>% factor %>% data.frame
Exposure
annotation_col <- rep("X=0",n0) %>% c(rep("X=1", n1)) %>% factor %>% data.frame
annotation_col
annotation_col <- rep("X=0",n0) %>%
c(rep("X=1", n1)) %>%
factor %>%
data.frame
colnames(annotation_col) <- "Exposure"
annotation_col
annotation_col <- rep("X=0",n0) %>%
c(rep("X=1", n1)) %>%
factor %>%
data.frame
colnames(annotation_col) <- "Exposure"
rownames(annotation_col) = paste0("Subject", 1:n)
annotation_col %>% head
servr::jekyll(script = "_knitr/build.R", serve = FALSE)
servr::jekyll(script = "_knitr/build.R", serve = FALSE)
servr::jekyll(script = "_knitr/build.R", serve = FALSE)
